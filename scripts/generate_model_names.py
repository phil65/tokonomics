"""Script to fetch models from all providers and generate separate files per provider."""

from __future__ import annotations

from collections import defaultdict
from datetime import timedelta
import logging
from pathlib import Path

from tokonomics.model_discovery import get_all_models_sync


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def _make_identifier(provider: str) -> str:
    """Convert provider name to valid Python identifier prefix."""
    # Special case for models.dev -> ModelsDev
    if provider == "modelsdev":
        return "ModelsDev"
    return provider.replace("-", "_").replace(".", "_").title().replace("_", "")


def generate_provider_file(
    provider: str,
    model_ids: list[str],
    model_names: list[str],
    output_dir: Path,
) -> tuple[str, str]:
    """Generate a Python file for a specific provider.

    Args:
        provider: Provider name
        model_ids: List of fully-qualified model IDs (provider:model)
        model_names: List of model names without provider prefix
        output_dir: Output directory path

    Returns:
        Tuple of (model_id_type_name, model_name_type_name)
    """
    # Create valid Python identifier from provider name
    prefix = _make_identifier(provider)
    model_id_type = f"{prefix}ModelId"
    model_name_type = f"{prefix}ModelName"
    filename = f"{provider.replace('-', '_').replace('.', '_').lower()}.py"

    formatted_ids = ",\n    ".join(f'"{mid}"' for mid in model_ids)
    formatted_names = ",\n    ".join(f'"{name}"' for name in model_names)

    content = f'''"""Generated model names for {provider} provider.

Auto-generated by scripts/generate_model_names.py - do not edit manually.
Total models: {len(model_ids)}
"""

from __future__ import annotations

from typing import Literal


# Fully-qualified model IDs (provider:model format)
{model_id_type} = Literal[
    {formatted_ids},
]

# Model names without provider prefix
{model_name_type} = Literal[
    {formatted_names},
]

__all__ = ["{model_id_type}", "{model_name_type}"]
'''

    file_path = output_dir / filename
    with file_path.open("w") as f:
        f.write(content)

    logger.info("Generated %s with %d models", file_path, len(model_ids))
    return model_id_type, model_name_type


def generate_init_file(
    provider_types: dict[str, tuple[str, str]],
    modelsdev_types: tuple[str, str] | None,
    all_model_ids: list[str],
    all_model_names: list[str],
    output_dir: Path,
) -> None:
    """Generate __init__.py with union of all provider types.

    Args:
        provider_types: Mapping of provider name to (model_id_type, model_name_type)
        modelsdev_types: Tuple of (model_id_type, model_name_type) for models.dev, or None
        all_model_ids: All model IDs across providers (for counting)
        all_model_names: All model names across providers (for counting)
        output_dir: Output directory path
    """
    imports = []
    model_id_types = []
    model_name_types = []

    # Sort providers to ensure consistent import order
    for provider, (model_id_type, model_name_type) in sorted(provider_types.items()):
        module_name = provider.replace("-", "_").replace(".", "_").lower()
        imports.append(f"from .{module_name} import {model_id_type}, {model_name_type}")
        model_id_types.append(model_id_type)
        model_name_types.append(model_name_type)

    # Add models.dev import separately (not included in unions)
    modelsdev_import = ""
    modelsdev_exports = []
    if modelsdev_types:
        modelsdev_id_type, modelsdev_name_type = modelsdev_types
        modelsdev_import = f"from .modelsdev import {modelsdev_id_type}, {modelsdev_name_type}"
        modelsdev_exports = [f'"{modelsdev_id_type}"', f'"{modelsdev_name_type}"']

    imports_str = "\n".join(imports)

    # Format ModelId union
    if model_id_types:
        formatted_id_types = [model_id_types[0], *[f"| {t}" for t in model_id_types[1:]]]
        model_id_union = "\n    ".join(formatted_id_types)
    else:
        model_id_union = ""

    # Format ModelName union
    if model_name_types:
        formatted_name_types = [model_name_types[0], *[f"| {t}" for t in model_name_types[1:]]]
        model_name_union = "\n    ".join(formatted_name_types)
    else:
        model_name_union = ""

    # Build __all__ exports
    all_exports = (
        [f'"{name}"' for name in model_id_types]
        + [f'"{name}"' for name in model_name_types]
        + modelsdev_exports
        + ['"ModelId"', '"ModelName"']
    )
    all_exports.sort()
    all_exports_str = ",\n    ".join(all_exports)

    # Build the imports section with models.dev separate
    if modelsdev_import:
        modelsdev_comment = "# models.dev aggregator (not included in ModelId/ModelName unions)"
        full_imports = f"{imports_str}\n\n{modelsdev_comment}\n{modelsdev_import}"
    else:
        full_imports = imports_str

    # Calculate unique counts
    unique_ids = len(set(all_model_ids))
    unique_names = len(set(all_model_names))
    total_ids = len(all_model_ids)
    total_names = len(all_model_names)

    content = f'''"""Generated model names from all providers.

Auto-generated by scripts/generate_model_names.py - do not edit manually.
Total providers: {len(provider_types)}
"""

from __future__ import annotations


{full_imports}

# Union of all provider model IDs (fully-qualified provider:model format)
# Total: {total_ids}, Unique: {unique_ids}
ModelId = (
    {model_id_union}
)

# Union of all provider model names (without provider prefix)
# Total: {total_names}, Unique: {unique_names} (duplicates exist across providers)
ModelName = (
    {model_name_union}
)

__all__ = [
    {all_exports_str},
]
'''

    init_path = output_dir / "__init__.py"
    with init_path.open("w") as f:
        f.write(content)

    logger.info("Generated %s with union of %d providers", init_path, len(provider_types))


def main() -> None:
    """Generate separate Python files for each provider with model names."""
    logger.info("Fetching models from all available providers...")

    # Fetch models with limited concurrency to avoid overwhelming APIs
    models = get_all_models_sync(max_workers=3, max_age=timedelta(days=200))
    models = [m for m in models if m.provider != "ollama"]
    if not models:
        logger.error("No models found")
        return

    # Fetch models.dev separately (aggregator, not a real provider)
    logger.info("Fetching models from models.dev aggregator...")
    modelsdev_models = get_all_models_sync(
        providers=["models.dev"], max_workers=1, max_age=timedelta(days=200)
    )

    # Group models by provider - store both full ID and just the model name
    models_by_provider: dict[str, set[tuple[str, str]]] = defaultdict(set)
    for model in models:
        # pydantic_ai_id is "provider:model_name"
        full_id = model.pydantic_ai_id
        # Extract just the model name (after the colon)
        model_name = full_id.split(":", 1)[1] if ":" in full_id else full_id
        models_by_provider[model.provider].add((full_id, model_name))

    # Sort and separate IDs and names for each provider
    sorted_models_by_provider: dict[str, tuple[list[str], list[str]]] = {}
    for provider, model_tuples in models_by_provider.items():
        sorted_tuples = sorted(model_tuples)
        model_ids = [t[0] for t in sorted_tuples]
        model_names = [t[1] for t in sorted_tuples]
        sorted_models_by_provider[provider] = (model_ids, model_names)

    total_models = sum(len(ids) for ids, _ in sorted_models_by_provider.values())
    logger.info(
        "Found %d unique models from %d providers",
        total_models,
        len(sorted_models_by_provider),
    )

    # Create output directory
    output_dir = Path("src/tokonomics/model_names")
    output_dir.mkdir(parents=True, exist_ok=True)

    # Collect all model IDs and names for counting
    all_model_ids: list[str] = []
    all_model_names: list[str] = []
    for model_ids, model_names in sorted_models_by_provider.values():
        all_model_ids.extend(model_ids)
        all_model_names.extend(model_names)

    # Generate file for each provider
    provider_types: dict[str, tuple[str, str]] = {}
    for provider, (model_ids, model_names) in sorted_models_by_provider.items():
        types = generate_provider_file(provider, model_ids, model_names, output_dir)
        provider_types[provider] = types

    # Generate anthropic-max as a derived provider from anthropic (same models, different auth)
    if "anthropic" in sorted_models_by_provider:
        _, anthropic_model_names = sorted_models_by_provider["anthropic"]
        anthropic_max_ids = [f"anthropic-max:{name}" for name in anthropic_model_names]
        types = generate_provider_file(
            "anthropic-max", anthropic_max_ids, anthropic_model_names, output_dir
        )
        provider_types["anthropic-max"] = types
        all_model_ids.extend(anthropic_max_ids)
        all_model_names.extend(anthropic_model_names)
        logger.info(
            "Generated anthropic-max with %d models (derived from anthropic)",
            len(anthropic_max_ids),
        )

    # Generate models.dev file separately
    modelsdev_types: tuple[str, str] | None = None
    if modelsdev_models:
        modelsdev_tuples: set[tuple[str, str]] = set()
        for model in modelsdev_models:
            full_id = model.pydantic_ai_id
            model_name = full_id.split(":", 1)[1] if ":" in full_id else full_id
            modelsdev_tuples.add((full_id, model_name))
        sorted_tuples = sorted(modelsdev_tuples)
        modelsdev_ids = [t[0] for t in sorted_tuples]
        modelsdev_names = [t[1] for t in sorted_tuples]
        modelsdev_types = generate_provider_file(
            "modelsdev", modelsdev_ids, modelsdev_names, output_dir
        )
        logger.info(
            "Generated models.dev with %d models (separate from unions)", len(modelsdev_ids)
        )

    # Generate __init__.py with union types (excluding models.dev from unions)
    generate_init_file(provider_types, modelsdev_types, all_model_ids, all_model_names, output_dir)

    # Log unique counts
    unique_ids = len(set(all_model_ids))
    unique_names = len(set(all_model_names))
    logger.info(
        "ModelId: %d total, %d unique | ModelName: %d total, %d unique",
        len(all_model_ids),
        unique_ids,
        len(all_model_names),
        unique_names,
    )

    logger.info("Generated model names package at %s", output_dir)


if __name__ == "__main__":
    main()
